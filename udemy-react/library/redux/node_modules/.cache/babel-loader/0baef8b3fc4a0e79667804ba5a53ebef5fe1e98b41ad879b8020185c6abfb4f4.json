{"ast":null,"code":"import { createStore } from 'redux';\nimport { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  counter: 0,\n  showCounter: true\n};\n\n// * 리덕스툴킷은 리덕스를 포함하기 때문에 리덕스가 설치되어 있다면 삭제하자!\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: initialState,\n  reducers: {\n    increment(state) {\n      // 리덕스툴킷의 createSlice를 쓰면 기존상태를 바꿀 수 없기 때문에\n      // 이렇게 간단히 사용할 수 있다. (자동으로 원래 있는 상태를 복제하기 때문)\n      state.counter++;\n    },\n    decrement(state) {\n      state.counter--;\n    },\n    increase(state, action) {\n      state.counter = state.counter + action.amount;\n    },\n    toggleCounter(state) {\n      state.showCounter = !state.showCounter;\n    }\n  }\n});\nconst store = createStore(counterSlice.reducer);\nexport default store;\n\n/*\n  // * 리덕스를 쓸때 단점\n  // 액션 타입의 오타가 날 확률이 높다 (충돌할 경우도 있음)\n  // 데이터 양이 많을 수록 상태 객체도 커지게되서 코드가 길어지고, 파일이 커진다.\n  const counterReducer = (state = initialState, action) => {\n    if (action.type === 'increment') {\n      // *** 리덕스뿐만 아니라 상태를 변경할 때는 절대 원본 상태 객체를 직접 수정하면 안된다.\n      // 상태의 불변성을 유지하기 위해, 항상 새로운 객체를 생성하여 반환해야 한다.\n      // 이를 통해 상태 변경을 감지할 수 있고, 리렌더링을 최적화할 수 있다.\n      // 아래 코드처럼 기존 상태의 복사본을 만들고 필요한 부분만 변경한 후, 새로운 객체를 반환.\n      return {\n        ...state, // 기존 상태 객체의 모든 속성을 복사\n        counter: state.counter + 1, // counter 속성만 업데이트\n      // 위 두 로직이 아래처럼 명시적으로 지정하는것과 똑같은 내용(스프레드연산자를 써서 간결한게 장점)\n      };\n    }\n\n    if (action.type === 'increase') {\n      return {\n        counter: state.counter + action.amount,\n        showCounter: state.showCounter,\n      };\n    }\n\n    if (action.type === 'decrement') {\n      return {\n        counter: state.counter - 1,\n        showCounter: state.showCounter,\n      };\n    }\n\n    if (action.type === 'toggle') {\n      return {\n        showCounter: !state.showCounter,\n        counter: state.counter,\n      };\n    }\n\n    return state;\n  };\n\n  const store = createStore(counterReducer);\n\n  export default store;\n*/","map":{"version":3,"names":["createStore","createSlice","initialState","counter","showCounter","counterSlice","name","reducers","increment","state","decrement","increase","action","amount","toggleCounter","store","reducer"],"sources":["/Users/donghanoh/Documents/react-study/udemy-react/basic-study/redux/src/store/index.js"],"sourcesContent":["import { createStore } from 'redux';\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = { counter: 0, showCounter: true };\n\n// * 리덕스툴킷은 리덕스를 포함하기 때문에 리덕스가 설치되어 있다면 삭제하자!\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: initialState,\n  reducers: {\n    increment(state) {\n      // 리덕스툴킷의 createSlice를 쓰면 기존상태를 바꿀 수 없기 때문에\n      // 이렇게 간단히 사용할 수 있다. (자동으로 원래 있는 상태를 복제하기 때문)\n      state.counter++;\n    },\n    decrement(state) {\n      state.counter--;\n    },\n    increase(state, action) {\n      state.counter = state.counter + action.amount;\n    },\n    toggleCounter(state) {\n      state.showCounter = !state.showCounter;\n    },\n  },\n});\n\nconst store = createStore(counterSlice.reducer);\n\nexport default store;\n\n/*\n  // * 리덕스를 쓸때 단점\n  // 액션 타입의 오타가 날 확률이 높다 (충돌할 경우도 있음)\n  // 데이터 양이 많을 수록 상태 객체도 커지게되서 코드가 길어지고, 파일이 커진다.\n  const counterReducer = (state = initialState, action) => {\n    if (action.type === 'increment') {\n      // *** 리덕스뿐만 아니라 상태를 변경할 때는 절대 원본 상태 객체를 직접 수정하면 안된다.\n      // 상태의 불변성을 유지하기 위해, 항상 새로운 객체를 생성하여 반환해야 한다.\n      // 이를 통해 상태 변경을 감지할 수 있고, 리렌더링을 최적화할 수 있다.\n      // 아래 코드처럼 기존 상태의 복사본을 만들고 필요한 부분만 변경한 후, 새로운 객체를 반환.\n      return {\n        ...state, // 기존 상태 객체의 모든 속성을 복사\n        counter: state.counter + 1, // counter 속성만 업데이트\n      // 위 두 로직이 아래처럼 명시적으로 지정하는것과 똑같은 내용(스프레드연산자를 써서 간결한게 장점)\n      };\n    }\n\n    if (action.type === 'increase') {\n      return {\n        counter: state.counter + action.amount,\n        showCounter: state.showCounter,\n      };\n    }\n\n    if (action.type === 'decrement') {\n      return {\n        counter: state.counter - 1,\n        showCounter: state.showCounter,\n      };\n    }\n\n    if (action.type === 'toggle') {\n      return {\n        showCounter: !state.showCounter,\n        counter: state.counter,\n      };\n    }\n\n    return state;\n  };\n\n  const store = createStore(counterReducer);\n\n  export default store;\n*/\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,OAAO;AACnC,SAASC,WAAW,QAAQ,kBAAkB;AAE9C,MAAMC,YAAY,GAAG;EAAEC,OAAO,EAAE,CAAC;EAAEC,WAAW,EAAE;AAAK,CAAC;;AAEtD;AACA,MAAMC,YAAY,GAAGJ,WAAW,CAAC;EAC/BK,IAAI,EAAE,SAAS;EACfJ,YAAY,EAAEA,YAAY;EAC1BK,QAAQ,EAAE;IACRC,SAASA,CAACC,KAAK,EAAE;MACf;MACA;MACAA,KAAK,CAACN,OAAO,EAAE;IACjB,CAAC;IACDO,SAASA,CAACD,KAAK,EAAE;MACfA,KAAK,CAACN,OAAO,EAAE;IACjB,CAAC;IACDQ,QAAQA,CAACF,KAAK,EAAEG,MAAM,EAAE;MACtBH,KAAK,CAACN,OAAO,GAAGM,KAAK,CAACN,OAAO,GAAGS,MAAM,CAACC,MAAM;IAC/C,CAAC;IACDC,aAAaA,CAACL,KAAK,EAAE;MACnBA,KAAK,CAACL,WAAW,GAAG,CAACK,KAAK,CAACL,WAAW;IACxC;EACF;AACF,CAAC,CAAC;AAEF,MAAMW,KAAK,GAAGf,WAAW,CAACK,YAAY,CAACW,OAAO,CAAC;AAE/C,eAAeD,KAAK;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}